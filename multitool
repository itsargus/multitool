import sys
import time
import socket
import psutil
import re
import ipaddress
import platform
import subprocess
from concurrent.futures import ThreadPoolExecutor, as_completed


# ---------- Имя сервиса по порту ----------

def get_service_name(port: int, proto: str = "tcp") -> str:
    """
    Имя сервиса по номеру порта.
    Берётся из системной БД (IANA-мэппинг, /etc/services и т.п.).
    Важно: это только предположение, реальный сервис может быть другим.
    """
    proto = proto.lower()
    try:
        return socket.getservbyport(port, proto)
    except OSError:
        return "unknown"


# ---------- Утилитные функции ----------

def fmt_addr(addr):
    if not addr:
        return "None"
    try:
        ip, port = addr[:2]
        return f"{ip}:{port}"
    except Exception:
        return str(addr)


def get_proc_name(pid):
    if not pid or pid == "None":
        return "None"
    try:
        return psutil.Process(int(pid)).name()
    except Exception:
        return "None"


# ---------- Локальный скан (как netstat++, с Service) ----------

def port_scan():
    socket_types = {
        socket.SOCK_STREAM: "TCP",
        socket.SOCK_DGRAM: "UDP",
        socket.SOCK_RAW: "RAW",
        socket.SOCK_SEQPACKET: "SEQPACKET",
        socket.SOCK_RDM: "RDM"
    }

    print()
    print(f"{'Proto':8} {'Local':40} {'Remote':30} {'State':12} {'PID':7} {'Process':18} {'Service'}")
    print("-" * 150)

    try:
        conns = psutil.net_connections(kind='all')
    except Exception as e:
        print("Не удалось получить соединения (возможно, нужны права администратора).")
        print("Ошибка:", e)
        return

    def sort_key(c):
        try:
            l = c.laddr
            ip = l.ip if hasattr(l, "ip") else (l[0] if l else "")
            port = l.port if hasattr(l, "port") else (l[1] if l else 0)
            return (str(c.type), str(ip), int(port) if port else 0)
        except Exception:
            return (str(c.type), "", 0)

    for c in sorted(conns, key=sort_key):
        proto = socket_types.get(c.type, str(c.type))
        laddr = fmt_addr(c.laddr)
        raddr = fmt_addr(c.raddr) if c.raddr else "None"
        state = c.status or "None"
        pid = c.pid or "None"
        pname = get_proc_name(pid)

        service = "unknown"
        try:
            if c.laddr:
                if hasattr(c.laddr, "port"):
                    lp = c.laddr.port
                else:
                    lp = c.laddr[1]
                proto_for_service = "tcp" if c.type == socket.SOCK_STREAM else "udp"
                service = get_service_name(int(lp), proto_for_service)
        except Exception:
            service = "unknown"

        print(f"{proto:8} {laddr:40} {raddr:30} {state:12} {str(pid):7} {pname:18} {service}")

    print("-" * 150)
    print(f"Всего соединений: {len(conns)}")
    print()


# ---------- Красивый баннер ----------

def print_animated_banner():
    banner = r"""
          _____                    _____                    _____                    _____                    _____          
         /\    \                  /\    \                  /\    \                  /\    \                  /\    \         
        /::\    \                /::\    \                /::\    \                /::\____\                /::\    \        
       /::::\    \              /::::\    \              /::::\    \              /:::/    /               /::::\    \       
      /::::::\    \            /::::::\    \            /::::::\    \            /:::/    /               /::::::\    \      
     /:::/\:::\    \          /:::/\:::\    \          /:::/\:::\    \          /:::/    /               /:::/\:::\    \     
    /:::/__\:::\    \        /:::/__\:::\    \        /:::/  \:::\    \        /:::/    /               /:::/__\:::\    \    
   /::::\   \:::\    \      /::::\   \:::\    \      /:::/    \:::\    \      /:::/    /                \:::\   \:::\    \   
  /::::::\   \:::\    \    /::::::\   \:::\    \    /:::/    / \:::\    \    /:::/    /      _____    ___\:::\   \:::\    \  
 /:::/\:::\   \:::\    \  /:::/\:::\   \:::\____\  /:::/    /   \:::\ ___\  /:::/____/      /\    \  /\   \:::\   \:::\    \ 
/:::/  \:::\   \:::\____\/:::/  \:::\   \:::|    |/:::/____/  ___\:::|    ||:::|    /      /::\____\/::\   \:::\   \:::\____\
\::/    \:::\  /:::/    /\::/   |::::\  /:::|____|\:::\    \ /\  /:::|____||:::|____\     /:::/    /\:::\   \:::\   \::/    /
 \/____/ \:::\/:::/    /  \/____|:::::\/:::/    /  \:::\    /::\ \::/    /  \:::\    \   /:::/    /  \:::\   \:::\   \/____/ 
          \::::::/    /         |:::::::::/    /    \:::\   \:::\ \/____/    \:::\    \ /:::/    /    \:::\   \:::\    \     
           \::::/    /          |::|\::::/    /      \:::\   \:::\____\       \:::\    /:::/    /      \:::\   \:::\____\    
           /:::/    /           |::| \::/____/        \:::\  /:::/    /        \:::\__/:::/    /        \:::\  /:::/    /    
          /:::/    /            |::|  ~|               \:::\/:::/    /          \::::::::/    /          \:::\/:::/    /     
         /:::/    /             |::|   |                \::::::/    /            \::::::/    /            \::::::/    /      
        /:::/    /              \::|   |                 \::::/    /              \::::/    /              \::::/    /       
        \::/    /                \:|   |                  \::/____/                \::/____/                \::/    /        
         \/____/                  \|___|                                            ~~                       \/____/     
"""
    green_color = "\033[92m"
    reset_color = "\033[0m"
    for line in banner.splitlines():
        print(green_color + line + reset_color)
        time.sleep(0.02)


# ---------- Удалённый скан TCP ----------

def check_tcp_port(host_ip, port, timeout=1.0):
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(timeout)
            res = s.connect_ex((host_ip, port))
            if res == 0:
                return "open"
            return "closed"
    except socket.timeout:
        return "filtered (timeout)"
    except ConnectionRefusedError:
        return "closed"
    except Exception:
        return "filtered (error)"


def resolve_target(target: str):
    target = target.strip()
    m = re.match(r'^\[(.+)\]:(\d+)$', target)
    if m:
        host_part = m.group(1)
        port_part = int(m.group(2))
    else:
        if ':' in target and target.count(':') == 1 and not target.startswith('['):
            host_part, port_s = target.split(':', 1)
            try:
                port_part = int(port_s)
            except ValueError:
                host_part, port_part = target, None
        else:
            host_part, port_part = target, None

    try:
        infos = socket.getaddrinfo(host_part, None, proto=socket.IPPROTO_TCP)
        target_ip = None
        for info in infos:
            sockaddr = info[4]
            if isinstance(sockaddr, tuple) and len(sockaddr) >= 1:
                target_ip = sockaddr[0]
                break
        if not target_ip:
            return None, None, None
        return host_part, target_ip, port_part
    except Exception:
        return None, None, None


def scan_remote_tcp(target, start_port=1, end_port=65535, workers=300, timeout=0.6):
    """
    Сканирование удалённого хоста по TCP.
    По умолчанию диапазон 1-65535 (все возможные порты).
    """
    host_part, target_ip, host_port = resolve_target(target)
    if not target_ip:
        print(f"[!] Невозможно разрешить хост {target}")
        return []

    if host_port is not None:
        start_port = host_port
        end_port = host_port

    ports = range(start_port, end_port + 1)
    results = []

    print(f"Сканирование {host_part} ({target_ip}) порты {start_port}-{end_port} "
          f"(threads={workers}, timeout={timeout})")

    with ThreadPoolExecutor(max_workers=workers) as ex:
        futures = {ex.submit(check_tcp_port, target_ip, p, timeout): p for p in ports}
        try:
            for fut in as_completed(futures):
                p = futures[fut]
                try:
                    status = fut.result()
                except Exception:
                    status = "error"
                results.append((p, status))
                if status == "open" or status.startswith("filtered"):
                    svc = get_service_name(p, "tcp")
                    print(f" {p:5} : {status:15} service={svc}")
        except KeyboardInterrupt:
            print("\n[!] Сканирование прервано пользователем")
            ex.shutdown(wait=False)

    results.sort()
    return results


def interactive_remote_scan():
    raw = input("Введите хост или IP для сканирования (можно host:port): ").strip()
    if not raw:
        print("Хост не введён.")
        return

    try:
        start = int(input("Начальный порт (1-65535) [по умолчанию 1]: ") or "1")
        end = int(input("Конечный порт (1-65535) [по умолчанию 65535]: ") or "65535")
    except ValueError:
        print("Порты должны быть числами.")
        return

    if start < 1 or end > 65535 or start > end:
        print("Неверный диапазон портов.")
        return

    try:
        workers = int(input("Потоков (threads) [по умолчанию 300]: ") or "300")
    except ValueError:
        workers = 300

    try:
        timeout = float(input("Таймаут в секундах [по умолчанию 0.6]: ") or "0.6")
    except ValueError:
        timeout = 0.6

    results = scan_remote_tcp(raw, start, end, workers=workers, timeout=timeout)
    open_ports = [p for p, s in results if s == "open"]
    filtered_ports = [p for p, s in results if s.startswith("filtered")]

    print()
    print(f"Открытые порты: {open_ports}" if open_ports else "Открытых портов не найдено.")
    if filtered_ports:
        print(f"Порты без ответа (filtered/timeout): {filtered_ports}")


# ---------- Banner grabbing ----------

def grab_banner(host: str, port: int, timeout: float = 2.0) -> str:
    """
    Пытаемся получить баннер с TCP-сервиса.
    Для некоторых портов (например HTTP) шлём простой запрос.
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(timeout)
            s.connect((host, port))

            # Для HTTP / веб-сервера отправим простой запрос
            if port in (80, 8080, 8000, 443):
                try:
                    req = b"GET / HTTP/1.0\r\nHost: %s\r\n\r\n" % host.encode()
                    s.sendall(req)
                except Exception:
                    pass

            try:
                data = s.recv(4096)
            except socket.timeout:
                return "[timeout при чтении баннера]"
            except Exception as e:
                return f"[ошибка при чтении баннера: {e}]"

            if not data:
                return "[сервер не прислал данных]"

            try:
                text = data.decode(errors="replace")
            except Exception:
                text = repr(data)

            return text.strip()
    except socket.timeout:
        return "[timeout при подключении]"
    except ConnectionRefusedError:
        return "[соединение отклонено (порт закрыт?)]"
    except Exception as e:
        return f"[ошибка при подключении: {e}]"


def interactive_banner_grab():
    raw_host = input("Хост или IP: ").strip()
    if not raw_host:
        print("Хост не введён.")
        return

    try:
        raw_port = input("Порт (1-65535): ").strip()
        port = int(raw_port)
    except ValueError:
        print("Порт должен быть числом.")
        return

    if port < 1 or port > 65535:
        print("Неверный номер порта.")
        return

    try:
        timeout = float(input("Таймаут в секундах [по умолчанию 2.0]: ") or "2.0")
    except ValueError:
        timeout = 2.0

    print(f"\n[*] Подключаемся к {raw_host}:{port}, пытаемся получить баннер...\n")
    banner = grab_banner(raw_host, port, timeout=timeout)
    print("===== БАННЕР НАЧАЛО =====")
    print(banner)
    print("===== БАННЕР КОНЕЦ =====\n")


# ---------- Пояснение статусов ----------

def print_status_explanation():
    print()
    print("Статус порта:")
    print(" • open — удалось соединиться (TCP connect).")
    print(" • closed — активно отвергнуто (RST / ConnectionRefused).")
    print(" • filtered (timeout) — нет ответа (файрвол или потеря пакетов).")
    print(" • filtered (error) / error — другая ошибка при проверке.")
    print()


# ---------- Скан всей локальной сети по ping ----------

def get_primary_ipv4_and_net():
    """
    Ищем основной IPv4 и его маску (по активному интерфейсу).
    Возвращает (ip, сеть IPv4Network) или (None, None)
    """
    addrs = psutil.net_if_addrs()
    stats = psutil.net_if_stats()

    for ifname, if_addrs in addrs.items():
        st = stats.get(ifname)
        if not st or not st.isup:
            continue

        for a in if_addrs:
            if a.family == socket.AF_INET:
                ip = a.address
                netmask = a.netmask
                try:
                    network = ipaddress.IPv4Network(f"{ip}/{netmask}", strict=False)
                    return ip, network
                except Exception:
                    continue

    return None, None


def ping_host(ip: str, timeout_ms: int = 1000) -> bool:
    """
    Пингуем хост.
    Для Windows используем: ping -n 1 -w TIMEOUT
    Для Linux/Mac: ping -c 1 -W TIMEOUT
    """
    system = platform.system().lower()
    if system == "windows":
        cmd = ["ping", "-n", "1", "-w", str(timeout_ms), ip]
    else:
        # timeout_ms -> seconds
        timeout_sec = max(1, int(timeout_ms / 1000))
        cmd = ["ping", "-c", "1", "-W", str(timeout_sec), ip]

    try:
        res = subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return res.returncode == 0
    except Exception:
        return False


def scan_local_network_ping(timeout_ms: int = 500):
    """
    Скан всей локальной сети по ping.
    Находит IP, которые отвечают.
    """
    local_ip, network = get_primary_ipv4_and_net()
    if not local_ip or not network:
        print("Не удалось определить локальный IP и сеть.")
        return

    print(f"\nЛокальный IP: {local_ip}")
    print(f"Сеть: {network}")
    print("Сканируем сеть ping'ами, это может занять время...\n")

    alive = []

    hosts = list(network.hosts())
    total = len(hosts)
    print(f"Всего хостов для проверки: {total}")

    def worker(ip_obj):
        ip_str = str(ip_obj)
        if ping_host(ip_str, timeout_ms=timeout_ms):
            return ip_str
        return None

    with ThreadPoolExecutor(max_workers=100) as ex:
        futures = {ex.submit(worker, ip): ip for ip in hosts}
        try:
            for i, fut in enumerate(as_completed(futures), 1):
                result = fut.result()
                if result:
                    alive.append(result)
                    print(f"[+] Хост доступен: {result}")
                if i % 50 == 0:
                    print(f"Проверено {i}/{total} адресов...")
        except KeyboardInterrupt:
            print("\n[!] Сканирование сети прервано пользователем.")

    print("\n=== РЕЗУЛЬТАТ СЕТЕВОГО СКАНА (PING) ===")
    if alive:
        for ip in alive:
            print(f" • {ip}")
    else:
        print("Активных хостов не найдено.")
    print()


def interactive_scan_local_network():
    try:
        timeout = float(input("Таймаут для ping в миллисекундах [по умолчанию 500]: ") or "500")
    except ValueError:
        timeout = 500.0

    timeout_ms = int(timeout)
    scan_local_network_ping(timeout_ms=timeout_ms)


# ---------- Меню ----------

def net_menu():
    while True:
        print("\n=== Сетевое меню ===")
        print("1 - Локальные IP и порты (скан соединений)")
        print("2 - Сканировать удалённый хост (TCP статус портов, до 65535)")
        print("3 - Пояснение статусов портов")
        print("4 - Banner-grabbing (получить баннер сервиса)")
        print("5 - Сканировать всю локальную сеть (ping)")
        print("0 - Назад")
        choice = input("Выберите пункт меню: ").strip()

        if choice == "1":
            try:
                port_scan()
            except KeyboardInterrupt:
                print("\nОперация прервана пользователем.")
        elif choice == "2":
            try:
                interactive_remote_scan()
            except KeyboardInterrupt:
                print("\nОперация прервана пользователем.")
        elif choice == "3":
            print_status_explanation()
        elif choice == "4":
            try:
                interactive_banner_grab()
            except KeyboardInterrupt:
                print("\nОперация прервана пользователем.")
        elif choice == "5":
            try:
                interactive_scan_local_network()
            except KeyboardInterrupt:
                print("\nСканирование сети прервано пользователем.")
        elif choice == "0":
            break
        else:
            print("Неизвестная команда, попробуйте ещё раз.")


def main_menu():
    while True:
        print("\nмультитул Argus")
        print("1 - Сетевые инструменты")
        print("0 - Выход")
        choice = input("Выберите пункт меню: ").strip()

        if choice == "1":
            net_menu()
        elif choice == "0":
            print("Выход...")
            time.sleep(0.3)
            sys.exit(0)
        else:
            print("Неизвестная команда, попробуйте ещё раз.")


if __name__ == "__main__":
    try:
        print_animated_banner()
        main_menu()
    except KeyboardInterrupt:
        print("\nПрограмма завершена (Ctrl+C).")
